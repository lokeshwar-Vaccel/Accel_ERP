import React, { useState, useEffect, useRef } from 'react';
import { useNavigate, useParams, useLocation } from 'react-router-dom';
import toast from 'react-hot-toast';
import { Package, Truck, User, MapPin, Calendar, FileText, Save, Printer, Send, ArrowLeft, Trash2, Download, ChevronDown, X } from 'lucide-react';
import PageHeader from './ui/PageHeader';
import { Button } from './ui/Botton';
import apiClient from '../utils/api';

// Types
interface DeliveryChallanItem {
  slNo: number;
  product?: string; // Product ID
  description: string;
  partNo: string;
  hsnSac: string;
  quantity: number;
  stockId?: string; // Stock ID for inventory tracking
  stockLocation?: {
    location: string;
    room: string;
    rack: string;
  };
  stockOperation?: 'add' | 'reduce'; // For edit mode
}

interface DeliveryChallan {
  _id?: string;
  challanNumber: string;
  dated: string;
  modeOfPayment: string;
  department: string;
  referenceNo: string;
  otherReferenceNo: string;
  buyersOrderNo: string;
  buyersOrderDate: string;
  dispatchDocNo: string;
  destination: string;
  dispatchedThrough: string;
  termsOfDelivery: string;
  consignee: string;
  customer: string;
  location: string; // From Location field
  spares: DeliveryChallanItem[];
  services: DeliveryChallanItem[];
  status: 'draft' | 'sent' | 'delivered' | 'cancelled';
  notes: string;
  // Customer details
  billToCustomer?: Customer;
  shipToCustomer?: Customer;
  // Invoice reference fields
  sourceInvoice?: string;
  invoiceNumber?: string;
  invoiceDate?: string;
  invoiceDetails?: {
    invoiceNumber: string;
    invoiceDate: string;
    totalAmount: number;
    customerName: string;
    items: Array<{
      description: string;
      quantity: number;
      unitPrice: number;
    }>;
  };
  createdBy?: string;
  createdAt?: string;
  updatedAt?: string;
}

interface Customer {
  _id: string;
  name: string;
  email: string;
  phone: string;
  addresses?: Array<{
    id: number;
    address: string;
    state: string;
    district: string;
    pincode: string;
    isPrimary: boolean;
    gstNumber?: string;
  }>;
}

interface Product {
  _id: string;
  name: string;
  partNo?: string;
  hsnNumber?: string;
  category: string;
  brand: string;
}

interface StockLocationData {
  _id: string;
  name: string;
  address: string;
  type: string;
}

interface StockProduct {
  _id: string; // Stock ID
  product: {
    _id: string;
    name: string;
    partNo?: string;
    brand: string;
    category: string;
    hsnNumber?: string;
    gst?: number;
    gndp?: number;
    price: number;
    uom?: string;
  };
  location: {
    _id: string;
    name: string;
  };
  room?: {
    _id: string;
    name: string;
  };
  rack?: {
    _id: string;
    name: string;
  };
  quantity: number;
  availableQuantity: number;
  reservedQuantity: number;
  stockLocation: {
    location: string;
    room: string;
    rack: string;
  };
}

const DeliveryChallanForm: React.FC = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const { id } = useParams<{ id: string }>();
  
  const isEditMode = Boolean(id);

  // State management
  const [customers, setCustomers] = useState<Customer[]>([]);
  const [products, setProducts] = useState<Product[]>([]);
  const [locations, setLocations] = useState<StockLocationData[]>([]);
  const [departments] = useState([
    'Retail', 'Corporate', 'Industrial Marine', 'Others'
  ]);
  
  // Stock management state (similar to Purchase Invoice)
  const [stockProducts, setStockProducts] = useState<StockProduct[]>([]);
  const [selectedLocationId, setSelectedLocationId] = useState<string>('');
  
  const [formData, setFormData] = useState<DeliveryChallan>({
    challanNumber: '', // Will be generated by backend (not displayed)
    dated: new Date().toISOString().split('T')[0],
    modeOfPayment: '',
    department: '',
    referenceNo: '',
    otherReferenceNo: '',
    buyersOrderNo: '',
    buyersOrderDate: '',
    dispatchDocNo: '',
    destination: '',
    dispatchedThrough: '',
    termsOfDelivery: '',
    consignee: '',
    customer: '',
    location: '', // From Location field
    spares: [],
    services: [], // Start with no services since they're optional
    status: 'draft',
    notes: '',
    // Customer details
    billToCustomer: undefined,
    shipToCustomer: undefined,
    // Invoice reference fields
    sourceInvoice: undefined,
    invoiceNumber: undefined,
    invoiceDate: undefined,
    invoiceDetails: undefined
  });

  const [errors, setErrors] = useState<Record<string, string>>({});
  const [loading, setLoading] = useState(false);
  const [submitting, setSubmitting] = useState(false);
  const [stockValidation, setStockValidation] = useState<Record<string, { available: number; isValid: boolean; message: string }>>({});
  const [productAvailability, setProductAvailability] = useState<Record<string, number>>({});
  const requestedAvailabilityRef = useRef<Set<string>>(new Set());

  // Product stock cache for location-based filtering (similar to Invoice Form)
  const [productStockCache, setProductStockCache] = useState<Record<string, {
    available: number;
    isValid: boolean;
    message: string;
    totalQuantity?: number;
    reservedQuantity?: number;
    stockDetails?: Array<{
      location: string;
      room: string;
      rack: string;
      available: number;
    }>;
  }>>({});

  // Stock loading state
  const [stockLoading, setStockLoading] = useState(false);
  
  // Stock cache version to force re-rendering when cache changes
  const [stockCacheVersion, setStockCacheVersion] = useState(0);

  // Stock allocation tracking for sequential consumption
  const [stockAllocation, setStockAllocation] = useState<Record<string, {
    productId: string;
    quantity: number;
    allocations: Array<{
      location: string;
      room: string;
      rack: string;
      allocatedQuantity: number;
      availableQuantity: number;
    }>;
    canFulfill: boolean;
  }>>({});

  const getAvailabilityClass = (productId: string) => {
    const available = productAvailability[productId];
    if (available === undefined) return 'text-gray-400';
    return available > 0 ? 'text-green-600' : 'text-red-500';
  };

  // Dropdown states
  const [showCustomerDropdown, setShowCustomerDropdown] = useState(false);
  const [showAddressDropdown, setShowAddressDropdown] = useState(false);
  const [showProductDropdowns, setShowProductDropdowns] = useState<Record<string, boolean>>({});
  const [showLocationDropdown, setShowLocationDropdown] = useState(false);
  const [customerSearchTerm, setCustomerSearchTerm] = useState('');
  const [selectedAddressId, setSelectedAddressId] = useState<string>('');
  const [selectedShipToAddressId, setSelectedShipToAddressId] = useState<string>('');
  const [productSearchTerms, setProductSearchTerms] = useState<Record<string, string>>({});
  const [locationSearchTerm, setLocationSearchTerm] = useState('');
  const [highlightedLocationIndex, setHighlightedLocationIndex] = useState(-1);

  // Refs for click outside handling
  const customerDropdownRef = useRef<HTMLDivElement>(null);





  // Fetch data on component mount
  useEffect(() => {
    console.log('Component mounted, isEditMode:', isEditMode, 'id:', id);
    console.log('Initial customers length:', customers.length);
    fetchAllData();
  }, []);

  // Handle challan data fetching based on edit mode
  useEffect(() => {
    if (isEditMode && id) {
      // Fetch existing delivery challan data for edit mode
      fetchDeliveryChallan();
    }
  }, [isEditMode, id]);

  // Monitor location changes for debugging
  useEffect(() => {
    console.log('🔍 Location changed:', formData.location);
    console.log('🔍 Location type:', typeof formData.location);
    console.log('🔍 Location truthy:', !!formData.location);
  }, [formData.location]);

  // Populate customer details when customers are loaded (for edit mode)
  useEffect(() => {
    if (isEditMode && id && customers.length > 0 && formData.customer) {
      console.log('Customers loaded, populating customer details for edit mode');
      console.log('Form data customer:', formData.customer);
      console.log('Available customers:', customers);
      
      // If we have the challan data but customers just loaded, populate customer details
      const foundCustomer = customers.find(c => c._id === formData.customer);
      console.log('Found customer for addresses:', foundCustomer);
      
      if (foundCustomer) {
        console.log('Setting customer search term:', foundCustomer.name);
        setCustomerSearchTerm(foundCustomer.name);
        
        if (foundCustomer.addresses && foundCustomer.addresses.length > 0) {
          console.log('Setting addresses from loaded customer');
          console.log('Available addresses:', foundCustomer.addresses);
          
          // Set the first address as default bill-to address
          setSelectedAddressId(foundCustomer.addresses[0].id.toString());
          
          // Match ship-to address from saved consignee if possible
          const savedConsignee = (formData.consignee || '').trim();
          const shipToMatch = foundCustomer.addresses.find((addr: any) => (addr.address || '').trim() === savedConsignee);
          if (shipToMatch) {
            console.log('Matched ship-to address from consignee (post-load):', shipToMatch);
            setSelectedShipToAddressId(shipToMatch.id.toString());
          } else {
            console.log('No exact match for consignee after customers load; leaving ship-to selection empty');
            setSelectedShipToAddressId('');
          }
        }
      }
    }
  }, [isEditMode, id, customers, formData.customer]);

  // After customers are loaded, if coming from invoice, set customerSearchTerm and address selection
  useEffect(() => {
    if (!isEditMode && customers.length > 0 && location.state?.customer) {
      const customer = location.state.customer;
      setCustomerSearchTerm(customer.name || '');
      // Find the customer in the loaded list and set address selections
      const foundCustomer = customers.find(c => c._id === customer._id);
      if (foundCustomer && foundCustomer.addresses && foundCustomer.addresses.length > 0) {
        // Set bill-to address
        if (location.state.billToAddress && location.state.billToAddress.id !== undefined) {
          setSelectedAddressId(String(location.state.billToAddress.id));
        } else {
          setSelectedAddressId(String(foundCustomer.addresses[0].id));
        }
        // Set ship-to address
        if (location.state.shipToAddress && location.state.shipToAddress.id !== undefined) {
          setSelectedShipToAddressId(String(location.state.shipToAddress.id));
        } else {
          setSelectedShipToAddressId('');
        }
      }
    }
  }, [isEditMode, customers, location.state]);

  // Monitor customers state changes
  useEffect(() => {
    console.log('Customers state changed:', customers.length);
    if (customers.length > 0) {
      console.log('First customer sample:', customers[0]);
    }
  }, [customers]);

  // Monitor formData.customer changes
  useEffect(() => {
    console.log('Form data customer changed:', formData.customer);
  }, [formData.customer]);

  // Monitor address selection changes
  useEffect(() => {
    console.log('Selected address ID changed:', selectedAddressId);
    console.log('Selected ship-to address ID changed:', selectedShipToAddressId);
  }, [selectedAddressId, selectedShipToAddressId]);

  // Monitor customer search term changes
  useEffect(() => {
    console.log('Customer search term changed:', customerSearchTerm);
  }, [customerSearchTerm]);

  // Monitor formData changes
  useEffect(() => {
    console.log('Form data changed:', {
      customer: formData.customer,
      department: formData.department,
      destination: formData.destination,
      dispatchedThrough: formData.dispatchedThrough
    });
  }, [formData.customer, formData.department, formData.destination, formData.dispatchedThrough]);

  // Monitor errors state changes
  useEffect(() => {
    console.log('Errors state changed:', errors);
  }, [errors]);

  // Load stock data when location is available and products are loaded
  useEffect(() => {
    if (formData.location && products.length > 0 && !loading && Object.keys(productStockCache).length === 0) {
      console.log('DeliveryChallanForm: Auto-loading stock for location:', formData.location);
      setTimeout(() => {
        loadAllStockForLocation(formData.location);
      }, 300);
    }
  }, [formData.location, products, loading, productStockCache]);

  // Click outside handlers
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (customerDropdownRef.current && !customerDropdownRef.current.contains(event.target as Node)) {
        setShowCustomerDropdown(false);
      }
      
      // Close location dropdown when clicking outside
      const target = event.target as Element;
      if (!target.closest('.dropdown-container') && !target.closest('input[data-field="location"]')) {
        setShowLocationDropdown(false);
        setHighlightedLocationIndex(-1);
      }
      
      // Close product dropdowns when clicking outside
      if (!target.closest('.product-dropdown') && !target.closest('input[placeholder*="search"]')) {
        setShowProductDropdowns({});
      }
    };

    const handleScroll = () => {
      // Close dropdowns when scrolling to prevent positioning issues
      setShowProductDropdowns({});
      setShowLocationDropdown(false);
      setHighlightedLocationIndex(-1);
    };

    const handleResize = () => {
      // Close dropdowns when resizing to prevent positioning issues
      setShowProductDropdowns({});
      setShowLocationDropdown(false);
      setHighlightedLocationIndex(-1);
    };

    document.addEventListener('mousedown', handleClickOutside);
    window.addEventListener('scroll', handleScroll);
    window.addEventListener('resize', handleResize);
    
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      window.removeEventListener('scroll', handleScroll);
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  // Prepopulate spares from invoice items if present in navigation state
  useEffect(() => {
    if (!isEditMode && formData.spares.length === 0 && location.state?.items) {
      const invoiceItems = location.state.items;
      const mappedSpares = invoiceItems.map((item: any, idx: number) => ({
        slNo: idx + 1,
        product: item.product._id || item.product, // Always use the product id string
        description: item.description,
        partNo: item.product.partNo || '',
        hsnSac: item.product.hsnNumber || '',
        quantity: item.quantity,
      }));
      // Prepopulate address IDs if available
      const billToAddress = location.state.billToAddress;
      const shipToAddress = location.state.shipToAddress;
      const customer = location.state.customer;
      console.log('billToAddress==>', billToAddress);
      console.log('shipToAddress==>', shipToAddress);
      console.log('customer==>', customer);
      if (billToAddress && billToAddress.id !== undefined) {
        setSelectedAddressId(String(billToAddress.id));
      }
      if (shipToAddress && shipToAddress.id !== undefined) {
        setSelectedShipToAddressId(String(shipToAddress.id));
      }
      
      setFormData(prev => ({
        ...prev,
        spares: mappedSpares,
        customer: customer?._id || '',
        billToCustomer: customer || undefined,
        shipToCustomer: customer || undefined,
        consignee: shipToAddress?.address || '',
        // Invoice reference fields
        sourceInvoice: location.state.sourceInvoice || undefined,
        invoiceNumber: location.state.invoiceNumber || undefined,
        invoiceDate: location.state.invoiceDate || undefined,
        invoiceDetails: location.state.invoiceDetails || undefined
      }));
    }
  }, [isEditMode, formData.spares.length, location.state]);

  const fetchAllData = async () => {
    try {
      console.log('Fetching all data...');
      await Promise.all([
        fetchCustomers(),
        fetchProducts(),
        fetchLocations()
      ]);
      console.log('All data fetched successfully');
      console.log('Customers after fetch:', customers.length);
    } catch (error) {
      console.error('Error fetching data:', error);
      toast.error('Failed to fetch required data');
    }
  };

  const fetchCustomers = async () => {
    try {
      console.log('Fetching customers...');
      const response = await apiClient.customers.getAllForDropdown();
      if (response.success) {
        console.log('Customers fetched successfully:', response.data.length);
        setCustomers(response.data);
      }
    } catch (error) {
      console.error('Error fetching customers:', error);
      toast.error('Failed to fetch customers');
    }
  };

  const fetchProducts = async () => {
    try {
      const response = await apiClient.products.getForDropdown({ limit: 1000 });
      if (response.success && response.data) {
        setProducts(response.data);
      }
    } catch (error) {
      console.error('Error fetching products:', error);
      toast.error('Failed to fetch products');
      setProducts([]);
    }
  };

  const fetchLocations = async () => {
    try {
      const response = await apiClient.stock.getLocations();
      let locationsData: any[] = [];

      if (response.data) {
        if (Array.isArray(response.data)) {
          locationsData = response.data;
        } else if ((response.data as any).locations && Array.isArray((response.data as any).locations)) {
          locationsData = (response.data as any).locations;
        }
      }

      setLocations(locationsData);
      console.log('✅ Loaded locations:', locationsData.length);

      // Set default location if not in edit mode
      if (!isEditMode && locationsData.length > 0) {
        const primaryLocation = locationsData.find(loc => loc.isPrimary === true);
        if (primaryLocation) {
          setFormData(prev => ({ ...prev, location: primaryLocation._id }));
          setLocationSearchTerm(primaryLocation.name);
          setSelectedLocationId(primaryLocation._id);
          
          // Auto-load stock for the default location after a short delay
          setTimeout(() => {
            console.log('DeliveryChallanForm: Auto-loading stock for default location:', primaryLocation._id);
            fetchProductsByLocation(primaryLocation._id);
          }, 500);
        } else {
          // Fallback to "Main Office" if no primary location is set
          const mainOffice = locationsData.find(loc => loc.name === "Main Office");
          if (mainOffice) {
            setFormData(prev => ({ ...prev, location: mainOffice._id }));
            setLocationSearchTerm(mainOffice.name);
            setSelectedLocationId(mainOffice._id);
            
            // Auto-load stock for the default location after a short delay
            setTimeout(() => {
              console.log('DeliveryChallanForm: Auto-loading stock for default location:', mainOffice._id);
              fetchProductsByLocation(mainOffice._id);
            }, 500);
          }
        }
      }
    } catch (error) {
      console.error('Error fetching locations:', error);
    }
  };

  // Fetch products by location (similar to Purchase Invoice)
  const fetchProductsByLocation = async (locationId: string, searchTerm?: string) => {
    try {
      // Fetch all products without pagination limit
      const params: any = { limit: 10000 }; // Set a very high limit to get all products
      if (searchTerm) {
        params.search = searchTerm;
      }

      const response = await apiClient.stock.getProductsByLocation(locationId, params);
      
      if (response.success && response.data?.products) {
        setStockProducts(response.data.products);
        setSelectedLocationId(locationId);
      } else {
        setStockProducts([]);
      }
    } catch (error) {
      console.error('Error fetching products by location:', error);
      toast.error('Failed to load products for selected location');
      setStockProducts([]);
    }
  };



  const fetchDeliveryChallan = async () => {
    if (!id) return;
    
    try {
      console.log('Fetching delivery challan with ID:', id);
      const response = await apiClient.deliveryChallans.getById(id);
      if (response.success && response.data?.deliveryChallan) {
        const challan = response.data.deliveryChallan;
        console.log('Fetched challan data:', challan);
        console.log('Customer data:', challan.customer);
        console.log('Available customers:', customers);
        
        // Set form data
        setFormData({
          challanNumber: challan.challanNumber || '', // Keep for backend reference but not displayed
          dated: challan.dated ? new Date(challan.dated).toISOString().split('T')[0] : new Date().toISOString().split('T')[0],
          modeOfPayment: challan.modeOfPayment || '',
          department: challan.department || '',
          referenceNo: challan.referenceNo || '',
          otherReferenceNo: challan.otherReferenceNo || '',
          buyersOrderNo: challan.buyersOrderNo || '',
          buyersOrderDate: challan.buyersOrderDate ? new Date(challan.buyersOrderDate).toISOString().split('T')[0] : '',
          dispatchDocNo: challan.dispatchDocNo || '',
          destination: challan.destination || '',
          dispatchedThrough: challan.dispatchedThrough || '',
          termsOfDelivery: challan.termsOfDelivery || '',
          consignee: challan.consignee || '',
          customer: challan.customer?._id || challan.customer || '',
          location: challan.location?._id || challan.location || '',
          spares: challan.spares || [],
          services: challan.services || [],
          status: challan.status || 'draft',
          notes: challan.notes || '',
          billToCustomer: challan.billToCustomer,
          shipToCustomer: challan.shipToCustomer,
          // Invoice reference fields
          sourceInvoice: challan.sourceInvoice?._id || challan.sourceInvoice || undefined,
          invoiceNumber: challan.invoiceNumber || undefined,
          invoiceDate: challan.invoiceDate ? new Date(challan.invoiceDate).toISOString().split('T')[0] : undefined,
          invoiceDetails: challan.invoiceDetails || undefined
        });

        // Set customer search term and populate customer details
        if (challan.customer) {
          const customerData = challan.customer;
          console.log('Processing customer data:', customerData);
          
          if (typeof customerData === 'object' && customerData.name) {
            // If customer is populated object
            console.log('Customer is populated object, setting search term:', customerData.name);
            setCustomerSearchTerm(customerData.name);
            
            // Find the customer in our customers list to get addresses
            const foundCustomer = customers.find(c => c._id === customerData._id);
            console.log('Found customer in list:', foundCustomer);
            
            if (foundCustomer && foundCustomer.addresses && foundCustomer.addresses.length > 0) {
              console.log('Setting addresses from found customer');
              // Set the first address as default bill-to address
              setSelectedAddressId(foundCustomer.addresses[0].id.toString());

              // Try to match ship-to address from DB consignee
              const savedConsignee = (challan.consignee || '').trim();
              const shipToMatch = foundCustomer.addresses.find((addr: any) => (addr.address || '').trim() === savedConsignee);
              if (shipToMatch) {
                console.log('Matched ship-to address from consignee:', shipToMatch);
                setSelectedShipToAddressId(shipToMatch.id.toString());
              } else {
                console.log('No exact match for consignee; leaving ship-to selection empty to preserve DB value');
                setSelectedShipToAddressId('');
              }
            }
          } else if (typeof customerData === 'string') {
            // If customer is just an ID, find the customer and set details
            console.log('Customer is string ID, finding customer:', customerData);
            const foundCustomer = customers.find(c => c._id === customerData);
            console.log('Found customer by ID:', foundCustomer);
            
            if (foundCustomer) {
              setCustomerSearchTerm(foundCustomer.name);
              
              if (foundCustomer.addresses && foundCustomer.addresses.length > 0) {
                console.log('Setting addresses from customer found by ID');
                // Set the first address as default bill-to address
                setSelectedAddressId(foundCustomer.addresses[0].id.toString());
                
                // Try to match ship-to address from DB consignee
                const savedConsignee = (challan.consignee || '').trim();
                const shipToMatch = foundCustomer.addresses.find((addr: any) => (addr.address || '').trim() === savedConsignee);
                if (shipToMatch) {
                  console.log('Matched ship-to address from consignee:', shipToMatch);
                  setSelectedShipToAddressId(shipToMatch.id.toString());
                } else {
                  console.log('No exact match for consignee; leaving ship-to selection empty to preserve DB value');
                  setSelectedShipToAddressId('');
                }
              }
            }
          }
        }

        // Set location search term and load stock if location is available
        if (challan.location) {
          const locationData = challan.location;
          console.log('Processing location data:', locationData);
          
          if (typeof locationData === 'object' && locationData.name) {
            // If location is populated object
            console.log('Location is populated object, setting search term:', locationData.name);
            setLocationSearchTerm(locationData.name);
            
            // Load stock for this location
            setTimeout(() => {
              fetchProductsByLocation(locationData._id);
            }, 500);
          } else if (typeof locationData === 'string') {
            // If location is just an ID, find the location and set details
            console.log('Location is string ID, finding location:', locationData);
            const foundLocation = locations.find(loc => loc._id === locationData);
            console.log('Found location by ID:', foundLocation);
            
            if (foundLocation) {
              setLocationSearchTerm(foundLocation.name);
              
              // Load stock for this location
              setTimeout(() => {
                fetchProductsByLocation(foundLocation._id);
              }, 500);
            }
          }
        }
      }
    } catch (error) {
      console.error('Error fetching delivery challan:', error);
      toast.error('Failed to fetch delivery challan data');
    }
  };

  // Form handlers
  const updateField = (field: keyof DeliveryChallan, value: any) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    // Clear error when field is updated
    if (errors[field]) {
      setErrors(prev => ({ ...prev, [field]: '' }));
    }
  };

  const updateSpareItem = (index: number, field: keyof DeliveryChallanItem, value: any) => {
    const updatedSpares = [...formData.spares];
    updatedSpares[index] = { ...updatedSpares[index], [field]: value };
    setFormData(prev => ({ ...prev, spares: updatedSpares }));
  };

  const updateServiceItem = (index: number, field: keyof DeliveryChallanItem, value: any) => {
    const updatedServices = [...formData.services];
    updatedServices[index] = { ...updatedServices[index], [field]: value };
    setFormData(prev => ({ ...prev, services: updatedServices }));
  };

  const addSpareItem = () => {
    const newSlNo = formData.spares.length + 1;
    setFormData(prev => ({
      ...prev,
      spares: [...prev.spares, { 
        slNo: newSlNo, 
        product: '', 
        description: '', 
        partNo: '', 
        hsnSac: '', 
        quantity: 0,
        stockOperation: isEditMode ? 'reduce' : undefined
      }]
    }));
  };

  const removeSpareItem = (index: number) => {
    const updatedSpares = formData.spares.filter((_, i) => i !== index);
    // Reorder sl numbers
    updatedSpares.forEach((item, i) => { item.slNo = i + 1; });
    setFormData(prev => ({ ...prev, spares: updatedSpares }));
  };

  const addServiceItem = () => {
    const newSlNo = formData.services.length + 1;
    setFormData(prev => ({
      ...prev,
      services: [...prev.services, { slNo: newSlNo, description: '', partNo: '', hsnSac: '', quantity: 0 }]
    }));
  };

  const removeServiceItem = (index: number) => {
    const updatedServices = formData.services.filter((_, i) => i !== index);
    // Reorder sl numbers
    updatedServices.forEach((item, i) => { item.slNo = i + 1; });
    setFormData(prev => ({ ...prev, services: updatedServices }));
  };

  // Customer selection
  const handleCustomerSelect = (customer: Customer) => {
    console.log('Customer selected:', customer);
    setFormData(prev => ({ ...prev, customer: customer._id }));
    setShowCustomerDropdown(false);
    setCustomerSearchTerm(customer.name);
    setSelectedAddressId(''); // Reset address selection when customer changes
    console.log('Customer selection updated, customer ID:', customer._id);
   
    // Clear customer-related errors
    setErrors(prev => {
      const newErrors = { ...prev };
      delete newErrors.customer;
      return newErrors;
    });
  };

  const handleAddressSelect = (addressId: string) => {
    console.log('Address selected:', addressId);
    setSelectedAddressId(addressId);
    setShowAddressDropdown(false);
   
    // Clear address error
    setErrors(prev => {
      const newErrors = { ...prev };
      delete newErrors.address;
      return newErrors;
    });
  };

  const handleShipToAddressSelect = (addressId: string) => {
    console.log('Ship-to address selected:', addressId);
    setSelectedShipToAddressId(addressId);
   
    // Clear ship-to address error
    setErrors(prev => {
      const newErrors = { ...prev };
      delete newErrors.shipToAddress;
      return newErrors;
    });
  };

  const getFilteredCustomers = () => {
    const term = (customerSearchTerm || '').toLowerCase();
    return customers.filter((customer) => {
      if (!customer) return false;
      const name = (customer.name || '').toLowerCase();
      const email = (customer.email || '').toLowerCase();
      return name.includes(term) || email.includes(term);
    });
  };

  const getSelectedCustomer = () => {
    const customer = customers.find(customer => customer._id === formData.customer);
    console.log('getSelectedCustomer called:', { customerId: formData.customer, foundCustomer: customer });
    return customer;
  };

  const getSelectedAddress = () => {
    const customer = getSelectedCustomer();
    if (!customer || !selectedAddressId) {
      console.log('getSelectedAddress: no customer or address ID', { customer, selectedAddressId });
      return null;
    }
    const address = customer.addresses?.find(addr => addr.id === parseInt(selectedAddressId));
    console.log('getSelectedAddress found:', address);
    return address;
  };

  const getSelectedShipToAddress = () => {
    const customer = getSelectedCustomer();
    if (!customer || !selectedShipToAddressId) {
      console.log('getSelectedShipToAddress: no customer or ship-to address ID', { customer, selectedShipToAddressId });
      return null;
    }
    const address = customer.addresses?.find((addr: any) => addr.id === parseInt(selectedShipToAddressId));
    console.log('getSelectedShipToAddress found:', address);
    return address;
  };

  // Location helper functions
  const getLocationLabel = (value: string) => {
    const location = locations.find(loc => loc._id === value);
    return location ? location.name : value;
  };

  const getFilteredLocations = () => {
    return locations.filter(location =>
      location.name.toLowerCase().includes(locationSearchTerm.toLowerCase()) ||
      location.address.toLowerCase().includes(locationSearchTerm.toLowerCase())
    );
  };

  // Location keyboard navigation handler (similar to Invoice Form)
  const handleLocationKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      setShowLocationDropdown(true);
      setHighlightedLocationIndex(prev => 
        prev < getFilteredLocations().length - 1 ? prev + 1 : 0
      );
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      setHighlightedLocationIndex(prev => 
        prev > 0 ? prev - 1 : getFilteredLocations().length - 1
      );
    } else if (e.key === 'Enter') {
      e.preventDefault();
      if (showLocationDropdown && highlightedLocationIndex >= 0 && getFilteredLocations()[highlightedLocationIndex]) {
        const selectedLocation = getFilteredLocations()[highlightedLocationIndex];
        console.log(`🔄 Location changed from ${formData.location} to ${selectedLocation._id} (${selectedLocation.name})`);
        setFormData({ ...formData, location: selectedLocation._id });
        setShowLocationDropdown(false);
        setHighlightedLocationIndex(-1);
        setLocationSearchTerm('');
        // Clear stock cache when location changes
        setProductStockCache({});
        setStockValidation({});

        // Refresh products for the new location
        setTimeout(() => {
          loadAllStockForLocation(selectedLocation._id);
        }, 100);
      }
    } else if (e.key === 'Escape') {
      setShowLocationDropdown(false);
      setHighlightedLocationIndex(-1);
    }
  };

  // Calculate sequential stock allocation for a product
  const calculateSequentialStockAllocation = (productId: string, requestedQuantity: number): {
    productId: string;
    quantity: number;
    allocations: Array<{
      location: string;
      room: string;
      rack: string;
      allocatedQuantity: number;
      availableQuantity: number;
    }>;
    canFulfill: boolean;
  } | null => {
    const stockInfo = productStockCache[productId];
    if (!stockInfo || !stockInfo.stockDetails || stockInfo.stockDetails.length === 0) {
      return null;
    }

    // Sort stock details by location, room, rack for consistent ordering
    const sortedStockDetails = [...stockInfo.stockDetails].sort((a, b) => {
      if (a.location !== b.location) return a.location.localeCompare(b.location);
      if (a.room !== b.room) return a.room.localeCompare(b.room);
      return a.rack.localeCompare(b.rack);
    });

    const allocations: Array<{
      location: string;
      room: string;
      rack: string;
      allocatedQuantity: number;
      availableQuantity: number;
    }> = [];

    let remainingQuantity = requestedQuantity;

    for (const stockDetail of sortedStockDetails) {
      if (remainingQuantity <= 0) break;

      const availableInThisLocation = stockDetail.available;
      const quantityToAllocate = Math.min(remainingQuantity, availableInThisLocation);

      if (quantityToAllocate > 0) {
        allocations.push({
          location: stockDetail.location,
          room: stockDetail.room,
          rack: stockDetail.rack,
          allocatedQuantity: quantityToAllocate,
          availableQuantity: availableInThisLocation
        });

        remainingQuantity -= quantityToAllocate;
      }
    }

    return {
      productId,
      quantity: requestedQuantity,
      allocations,
      canFulfill: remainingQuantity === 0
    };
  };

  // Product selection for spares - Auto-fills description, part number, and HSN/SAC
  // Quantity remains unchanged as user will enter it manually
  const handleProductSelect = (itemIndex: number, stockId: string) => {
    const stockProduct = stockProducts.find(sp => sp._id === stockId);
    if (stockProduct) {
      // Update the form data first
      const updatedSpares = [...formData.spares];
      updatedSpares[itemIndex] = {
        ...updatedSpares[itemIndex],
        product: stockProduct.product._id, // Store product ID
        description: stockProduct.product.name,
        partNo: stockProduct.product.partNo || '',
        hsnSac: stockProduct.product.hsnNumber || '',
        stockId: stockProduct._id, // Store stock ID
        stockLocation: stockProduct.stockLocation
      };
      
      setFormData(prev => {
        const newState = { ...prev, spares: updatedSpares };
        return newState;
      });
      
      // Clear the search term and close dropdown
      updateProductSearchTerm(itemIndex, '', 'spares');
      setShowProductDropdowns(prev => ({ ...prev, [`spares-${itemIndex}`]: false }));
      
      // Debug log to ensure stock ID is being set correctly
      console.log(`Selected stock for product ${stockProduct.product.name}:`, {
        productId: stockProduct.product._id,
        stockId: stockProduct._id,
        location: stockProduct.stockLocation.location,
        room: stockProduct.stockLocation.room,
        rack: stockProduct.stockLocation.rack,
        availableQuantity: stockProduct.availableQuantity
      });
      
      // Validate stock for the selected product
      if (updatedSpares[itemIndex].quantity > 0) {
        validateStockForItem(itemIndex, stockProduct.product._id, updatedSpares[itemIndex].quantity);
      }
    }
  };

  // Load ALL stock data for a location - FASTEST approach (similar to Invoice Form)
  const loadAllStockForLocation = async (locationId?: string) => {
    const currentLocation = locationId || formData.location;
    if (!currentLocation) return;

    setStockLoading(true);
    try {
      // Get ALL stock data for this location in ONE API call - no limits
      const response = await apiClient.stock.getStock({
        location: currentLocation,
        limit: 10000 // Get all stock items for this location
      });

      // Parse the stock data correctly from API response
      let stockData: any[] = [];
      if (response.data?.stockLevels && Array.isArray(response.data.stockLevels)) {
        stockData = response.data.stockLevels;
      }

      console.log('✅ Loaded stock data for location:', stockData.length, 'items');

      // Create complete stock cache for ALL products at this location
      // Aggregate stock across all rooms and racks within the location
      const newStockCache: any = {};
      const stockAggregation = new Map(); // Map to aggregate stock by product ID
      
      stockData.forEach(stock => {
        const productId = stock.product?._id || stock.product;
        if (productId) {
          // Calculate available quantity correctly
          const totalQuantity = Number(stock.quantity) || 0;
          const reservedQuantity = Number(stock.reservedQuantity) || 0;
          const available = Math.max(0, totalQuantity - reservedQuantity);

          if (!stockAggregation.has(productId)) {
            stockAggregation.set(productId, {
              totalAvailable: 0,
              totalQuantity: 0,
              totalReserved: 0,
              stockDetails: []
            });
          }
          
          const aggregatedStock = stockAggregation.get(productId);
          
          aggregatedStock.totalAvailable += available;
          aggregatedStock.totalQuantity += totalQuantity;
          aggregatedStock.totalReserved += reservedQuantity;
          
          if (available > 0) {
            aggregatedStock.stockDetails.push({
              location: stock.location?.name || 'Unknown Location',
              room: stock.room?.name || '',
              rack: stock.rack?.name || '',
              available: available
            });
          }
        }
      });
      
      stockAggregation.forEach((aggregatedStock, productId) => {
        newStockCache[productId] = {
          available: aggregatedStock.totalAvailable,
          isValid: aggregatedStock.totalAvailable > 0,
          message: aggregatedStock.totalAvailable === 0 ? 'Out of stock' : `${aggregatedStock.totalAvailable} available`,
          totalQuantity: aggregatedStock.totalQuantity,
          reservedQuantity: aggregatedStock.totalReserved,
          stockDetails: aggregatedStock.stockDetails
        };
      });

      // Set stock info for products that don't have stock at this location
      products.forEach(product => {
        if (!newStockCache[product._id]) {
          newStockCache[product._id] = {
            available: 0,
            isValid: false,
            message: 'Out of stock',
            totalQuantity: 0,
            reservedQuantity: 0
          };
        }
      });

      // Update cache with complete stock data
      setProductStockCache(newStockCache);
      setStockCacheVersion(prev => prev + 1); // Force re-render of product dropdowns
      console.log('✅ Stock cache updated for', Object.keys(newStockCache).length, 'products');

    } catch (error) {
      console.error('❌ Error loading stock for location:', error);
      const errorStockCache: any = {};
      products.forEach(product => {
        errorStockCache[product._id] = {
          available: 0,
          isValid: false,
          message: 'Unable to check stock',
          totalQuantity: 0,
          reservedQuantity: 0
        };
      });
      setProductStockCache(errorStockCache);
    } finally {
      setStockLoading(false);
    }
  };

  // Get filtered products for dropdown display with location-based filtering
  const getFilteredProducts = (searchTerm: string = '') => {
    // If no location is selected, return empty array
    if (!selectedLocationId) {
      return [];
    }

    const term = searchTerm.toLowerCase().trim();
    let filteredProducts = stockProducts;

    // If no search term, return all stock products
    if (!term) return filteredProducts;

    // Apply search term filtering
    filteredProducts = filteredProducts.filter(stockProduct => {
      const name = stockProduct.product.name?.toLowerCase() || '';
      const partNo = stockProduct.product.partNo?.toLowerCase() || '';
      const category = stockProduct.product.category?.toLowerCase() || '';
      const brand = stockProduct.product.brand?.toLowerCase() || '';

      return name.includes(term) ||
        partNo.includes(term) ||
        category.includes(term) ||
        brand.includes(term) ||
        name.startsWith(term) ||
        partNo.startsWith(term);
    });

    return filteredProducts.sort((a, b) => {
      const aName = a.product.name?.toLowerCase() || '';
      const aPartNo = a.product.partNo?.toLowerCase() || '';
      const bName = b.product.name?.toLowerCase() || '';
      const bPartNo = b.product.partNo?.toLowerCase() || '';

      if (aName === term && bName !== term) return -1;
      if (bName === term && aName !== term) return 1;
      if (aPartNo === term && bPartNo !== term) return -1;
      if (bPartNo === term && aPartNo !== term) return 1;

      if (aName.startsWith(term) && !bName.startsWith(term)) return -1;
      if (bName.startsWith(term) && !aName.startsWith(term)) return 1;
      if (aPartNo.startsWith(term) && !bPartNo.startsWith(term)) return -1;
      if (bPartNo.startsWith(term) && !aPartNo.startsWith(term)) return 1;

      return aName.localeCompare(bName);
    });
  };

  const fetchAvailabilityForProduct = async (productId: string) => {
    if (!productId) return;
    if (requestedAvailabilityRef.current.has(productId)) return;
    requestedAvailabilityRef.current.add(productId);
    try {
      const response = await apiClient.stock.getStock({ product: productId });
      let stockData: any[] = [];
      if (response.data) {
        if (Array.isArray(response.data)) {
          stockData = response.data;
        } else if (response.data.stockLevels && Array.isArray(response.data.stockLevels)) {
          stockData = response.data.stockLevels;
        }
      }
      const stockItem = stockData.length > 0 ? stockData[0] : null;
      const available = stockItem ? (stockItem.availableQuantity || (stockItem.quantity - (stockItem.reservedQuantity || 0))) : 0;
      setProductAvailability(prev => ({ ...prev, [productId]: available }));
    } catch (e) {
      setProductAvailability(prev => ({ ...prev, [productId]: 0 }));
    }
  };

  const prefetchAvailabilityForVisibleProducts = (itemIndex: number, searchTerm?: string) => {
    const term = searchTerm !== undefined ? searchTerm : (productSearchTerms[`spares-${itemIndex}`] || '');
    const visible = getFilteredProducts(term).slice(0, 30);
    visible.forEach(p => fetchAvailabilityForProduct(p._id));
  };

  const updateProductSearchTerm = (itemIndex: number, searchTerm: string, type: 'spares' | 'services') => {
    setProductSearchTerms(prev => ({ ...prev, [`${type}-${itemIndex}`]: searchTerm }));
  };

  // Create new product if it doesn't exist (only for spares now)
  const handleCreateNewProduct = async (productName: string, itemIndex: number) => {
    try {
      // Check if product already exists
      const existingProduct = products.find(p => p.name.toLowerCase() === productName.toLowerCase());
      if (existingProduct) {
        // Product exists, select it
        handleProductSelect(itemIndex, existingProduct._id);
        return;
      }

      // Create new product
      const newProductData = {
        name: productName,
        category: 'Spares',
        brand: 'General',
        price: 0,
        isActive: true
      };

      const response = await apiClient.products.create(newProductData);
      if (response.success) {
        const newProduct = response.data.product;
        setProducts(prev => [...prev, newProduct]);
        
        // Select the newly created product
        handleProductSelect(itemIndex, newProduct._id);
        
        toast.success(`New product "${productName}" created successfully`);
      }
    } catch (error) {
      console.error('Error creating new product:', error);
      toast.error('Failed to create new product');
    }
  };

  // Validate stock for spare items
  const validateStockForItem = async (itemIndex: number, productId: string, quantity: number) => {
    if (!productId || quantity <= 0) {
      setStockValidation(prev => ({
        ...prev,
        [itemIndex]: { available: 0, isValid: true, message: '' }
      }));
      return;
    }

    try {
      const response = await apiClient.stock.getStock({
        product: productId
      });

      let stockData: any[] = [];
      if (response.data) {
        if (Array.isArray(response.data)) {
          stockData = response.data;
        } else if (response.data.stockLevels && Array.isArray(response.data.stockLevels)) {
          stockData = response.data.stockLevels;
        }
      }

      const stockItem = stockData.length > 0 ? stockData[0] : null;
      const available = stockItem ? (stockItem.availableQuantity || (stockItem.quantity - (stockItem.reservedQuantity || 0))) : 0;

      const isValid = quantity <= available && available > 0;
      // Show toast if quantity exceeds available stock
      if (!isValid && available === 0) {
        toast.error(`Product is out of stock`);
      } else if (!isValid) {
        toast.error(`Quantity ${quantity} exceeds available stock. Only ${available} units available`);
      }

      setStockValidation(prev => ({
        ...prev,
        [itemIndex]: { available, isValid, message: '' }
      }));
    } catch (error) {
      console.error('Error validating stock:', error);
      setStockValidation(prev => ({
        ...prev,
        [itemIndex]: { available: 0, isValid: false, message: '' }
      }));
    }
  };

  // Validation
  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};

    console.log('Validating form with data:', {
      customer: formData.customer,
      selectedAddressId,
      selectedShipToAddressId,
      department: formData.department,
      destination: formData.destination,
      dispatchedThrough: formData.dispatchedThrough
    });

    if (!formData.customer) newErrors.customer = 'Customer is required';
    if (!selectedAddressId) newErrors.address = 'Address is required';
    if (!selectedShipToAddressId && !(formData.consignee && formData.consignee.trim() !== '')) newErrors.shipToAddress = 'Ship-to address or saved consignee is required';
    if (!formData.department) newErrors.department = 'Department is required';
    if (!formData.destination) newErrors.destination = 'Destination is required';
    if (!formData.location) newErrors.location = 'From Location is required';

    // Validate spares - once a row is added, all mandatory fields must be filled
    formData.spares.forEach((item, index) => {
      // Check if this is an empty row (all fields empty/default)
      const isEmpty = !item.product && !item.description && !item.partNo && !item.hsnSac && item.quantity === 0;
      
      if (!isEmpty) {
        // Row has some data, validate all mandatory fields
        if (!item.description) {
          newErrors[`spare-${index}-description`] = 'Description is required - fill all fields or remove this row';
        }
        if (!item.product) {
          newErrors[`spare-${index}-product`] = 'Product selection is required - fill all fields or remove this row';
        }
        if (item.quantity <= 0) {
          newErrors[`spare-${index}-quantity`] = 'Quantity must be greater than 0 - fill all fields or remove this row';
        }
      }
    });

    // Validate services - once a row is added, all mandatory fields must be filled
    formData.services.forEach((item, index) => {
      // Check if this is an empty row (all fields empty/default)
      const isEmpty = !item.description && !item.partNo && !item.hsnSac && item.quantity === 0;
      
      if (!isEmpty) {
        // Row has some data, validate all mandatory fields
        if (!item.description) {
          newErrors[`service-${index}-description`] = 'Description is required - fill all fields or remove this row';
        }
        if (item.quantity <= 0) {
          newErrors[`service-${index}-quantity`] = 'Quantity must be greater than 0 - fill all fields or remove this row';
        }
      }
    });

    console.log('Validation errors:', newErrors);
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // PDF Export handler
  const handleExportPDF = async () => {
    if (!id) {
      toast.error('Please save the delivery challan first before exporting to PDF');
      return;
    }

    try {
      setLoading(true);
      const pdfBlob = await apiClient.deliveryChallans.exportPDF(id);
      
      // Create download link
      const url = window.URL.createObjectURL(pdfBlob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `delivery-challan-${formData.challanNumber || 'draft'}.pdf`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
      
      toast.success('PDF exported successfully');
    } catch (error: any) {
      console.error('Error exporting PDF:', error);
      toast.error(error.message || 'Failed to export PDF');
    } finally {
      setLoading(false);
    }
  };

  // Handle stock reduction for new delivery challan
  const handleStockReductionForNew = async (spares: any[]) => {
    for (const item of spares) {
      if (item.stockId && item.quantity > 0) {
        try {
          console.log(`Reducing stock for item:`, {
            productName: item.description,
            productId: item.product,
            stockId: item.stockId,
            quantity: item.quantity,
            stockLocation: item.stockLocation,
            formDataLocation: formData.location
          });
          
          // const stockAdjustmentData = {
          //   stockId: item.stockId,
          //   product: item.product,
          //   location: formData.location,
          //   adjustmentType: 'subtract',
          //   quantity: item.quantity,
          //   reason: `Delivery Challan - Reduced ${item.quantity} units`,
          //   notes: `Delivery challan created with ${item.quantity} units reduced from stock at ${item.stockLocation?.location} → ${item.stockLocation?.room} → ${item.stockLocation?.rack}`
          // };
          
          // console.log('Stock reduction data being sent:', stockAdjustmentData);
          
          // await apiClient.stock.adjustStock(stockAdjustmentData);
          
          console.log(`Successfully reduced stock for ${item.description}`);
        } catch (error) {
          console.error('Error reducing stock:', error);
          toast.error(`Failed to reduce stock for ${item.description || 'product'}`);
        }
      }
    }
  };

  // Handle stock operations for edit mode (both add and reduce)
  const handleStockOperationsForEdit = async (spares: any[]) => {
    for (const item of spares) {
      if (item.stockId && item.quantity > 0) {
        try {
          const operation = item.stockOperation || 'reduce';
          const operationText = operation === 'add' ? 'Added' : 'Reduced';
          const adjustmentType = operation === 'add' ? 'add' : 'subtract';
          
          console.log(`Stock operation for item:`, {
            productName: item.description,
            productId: item.product,
            stockId: item.stockId,
            quantity: item.quantity,
            operation: operation,
            stockLocation: item.stockLocation,
            formDataLocation: formData.location
          });
          
          const stockAdjustmentData = {
            stockId: item.stockId,
            product: item.product,
            location: formData.location,
            adjustmentType: adjustmentType,
            quantity: item.quantity,
            reason: `Delivery Challan Edit - ${operationText} ${item.quantity} units`,
            notes: `Delivery challan edited with ${item.quantity} units ${operationText.toLowerCase()} from stock at ${item.stockLocation?.location} → ${item.stockLocation?.room} → ${item.stockLocation?.rack}`
          };
          
          console.log('Stock operation data being sent:', stockAdjustmentData);
          
          await apiClient.stock.adjustStock(stockAdjustmentData);
          
          console.log(`Successfully ${operationText.toLowerCase()} stock for ${item.description}`);
        } catch (error) {
          console.error('Error updating stock:', error);
          toast.error(`Failed to update stock for ${item.description || 'product'}`);
        }
      }
    }
  };

  // Submit handler
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    console.log('Form submitted, validating...');
    console.log('Current formData.location:', formData.location);
    console.log('Current formData:', formData);
    
    if (!validateForm()) {
      console.log('Validation failed, errors:', errors);
      toast.error('Please fix the errors in the form');
      return;
    }
    console.log('Validation passed, submitting...');

    // Double-check that location is set before submission
    if (!formData.location) {
      console.error('Location is empty but validation passed - this should not happen');
      toast.error('Please select a From Location before submitting');
      return;
    }

    setSubmitting(true);
    try {
      // Prepare data for API - include all fields from the form
      // Filter out completely empty rows from spares
      const sanitizedSpares = (formData.spares || []).filter((item) => {
        return item.product || item.description || item.partNo || item.hsnSac || item.quantity > 0;
      });
      
      // Filter out completely empty rows from services
      const sanitizedServices = (formData.services || []).filter((item) => {
        return item.description || item.partNo || item.hsnSac || item.quantity > 0;
      });
      
      // Prepare stock allocation data for spares
      const sparesWithAllocation = sanitizedSpares.map((spare, index) => {
        const allocationKey = `${spare.product}-${index}`;
        const allocation = stockAllocation[allocationKey];
        
        const spareData: any = { ...spare };
        
        if (allocation) {
          spareData.stockAllocation = {
            allocations: allocation.allocations,
            canFulfill: allocation.canFulfill
          };
        }
        
        return spareData;
      });

      const challanData = {
        // Only include challanNumber for edit mode, let backend generate for new challans
        ...(isEditMode && { challanNumber: formData.challanNumber }),
        dated: formData.dated,
        modeOfPayment: formData.modeOfPayment || '',
        department: formData.department,
        referenceNo: formData.referenceNo || '',
        otherReferenceNo: formData.otherReferenceNo || '',
        buyersOrderNo: formData.buyersOrderNo || '',
        buyersOrderDate: formData.buyersOrderDate || '',
        dispatchDocNo: formData.dispatchDocNo || '',
        destination: formData.destination,
        dispatchedThrough: formData.dispatchedThrough,
        termsOfDelivery: formData.termsOfDelivery || '',
        consignee: selectedShipToAddressId ? (getSelectedShipToAddress()?.address || '') : (formData.consignee || ''),
        customer: formData.customer,
        location: formData.location, // Always include location (should be validated above)
        spares: sparesWithAllocation,
        services: sanitizedServices,
        status: formData.status,
        notes: formData.notes || '',
        // Invoice reference fields
        sourceInvoice: formData.sourceInvoice || undefined,
        invoiceNumber: formData.invoiceNumber || undefined,
        invoiceDate: formData.invoiceDate || undefined,
        invoiceDetails: formData.invoiceDetails || undefined
      };

      console.log('Submitting challan data:', challanData);
      console.log('Location field:', formData.location);
      console.log('Stock allocation data:', stockAllocation);
      console.log('Spares with allocation:', sparesWithAllocation);
      console.log('Selected ship-to address:', getSelectedShipToAddress());
      console.log('Selected address ID:', selectedShipToAddressId);

      if (isEditMode) {
        const response = await apiClient.deliveryChallans.update(id!, challanData);
        if (response.success) {
          // Handle stock operations for edit mode
          await handleStockOperationsForEdit(sparesWithAllocation);
          toast.success('Delivery Challan updated successfully');
          navigate('/billing');
        }
      } else {
        const response = await apiClient.deliveryChallans.create(challanData);
        if (response.success) {
          // Handle stock reduction for new challan
          await handleStockReductionForNew(sparesWithAllocation);
          const challanNumber = response.data?.deliveryChallan?.challanNumber;
          toast.success(`Delivery Challan created successfully! Challan number: ${challanNumber}`);
          localStorage.setItem('selectedInvoiceType', 'challan');
          navigate('/billing');
        }
      }
    } catch (error: any) {
      console.error('Error saving delivery challan:', error);
      // Prefer backend error message if present
      const backendMsg = error?.response?.data?.message || error?.message || error?.error;
      toast.error(backendMsg || 'Failed to save delivery challan');
    } finally {
      setSubmitting(false);
    }
  };

  // Debug current state
  console.log('Rendering form with state:', {
    isEditMode,
    id,
    customer: formData.customer,
    customerSearchTerm,
    selectedAddressId,
    selectedShipToAddressId,
    customersLength: customers.length,
    selectedCustomer: getSelectedCustomer(),
    selectedAddress: getSelectedAddress(),
    selectedShipToAddress: getSelectedShipToAddress(),
    errors,
    formData: {
      customer: formData.customer,
      department: formData.department,
      destination: formData.destination,
      dispatchedThrough: formData.dispatchedThrough
    },
    customersSample: customers.slice(0, 2).map(c => ({ id: c._id, name: c.name, addressesCount: c.addresses?.length || 0 })),
    selectedCustomerAddresses: getSelectedCustomer()?.addresses?.map(addr => ({ id: addr.id, address: addr.address, district: addr.district, pincode: addr.pincode })),
    selectedAddressDetails: getSelectedAddress() ? { id: getSelectedAddress()?.id, address: getSelectedAddress()?.address, district: getSelectedAddress()?.district, pincode: getSelectedAddress()?.pincode } : null,
    selectedShipToAddressDetails: getSelectedShipToAddress() ? { id: getSelectedShipToAddress()?.id, address: getSelectedShipToAddress()?.address, district: getSelectedShipToAddress()?.district, pincode: getSelectedShipToAddress()?.pincode } : null,
    validationState: {
      hasCustomer: !!formData.customer,
      hasAddress: !!selectedAddressId,
      hasShipToAddress: !!selectedShipToAddressId,
      hasDepartment: !!formData.department,
      hasDestination: !!formData.destination,
      hasDispatchedThrough: !!formData.dispatchedThrough
    },
    submissionState: {
      submitting,
      loading
    },
    formDataStructure: {
      sparesCount: formData.spares?.length || 0,
      servicesCount: formData.services?.length || 0,
      hasChallanNumber: !!formData.challanNumber,
      hasNotes: !!formData.notes
    },
    timing: {
      customersLoaded: customers.length > 0,
      challanLoaded: isEditMode ? !!id : true,
      addressesPopulated: !!(selectedAddressId && selectedShipToAddressId)
    }
  });

  return (
    <div className="pl-2 pr-6 py-6 space-y-4">
      <PageHeader
        title={isEditMode ? 'Edit Delivery Challan' : 'Create New Delivery Challan'}
        subtitle="Create a delivery challan for goods and services"
      >
        <div className="flex items-center space-x-3">
          <Button
            onClick={() => navigate('/billing')}
            variant="outline"
            className="flex items-center space-x-2"
          >
            <ArrowLeft className="w-4 h-4" />
            <span>Back to Billing</span>
          </Button>
        </div>
      </PageHeader>

      {/* Form */}
      <div className="bg-white shadow rounded-lg">
        <form id="delivery-challan-form" onSubmit={handleSubmit}>
          {/* Header Section */}
          <div className="px-6 py-4 border-b border-gray-200">
            <div className="text-center">
              <h2 className="text-2xl font-bold text-gray-900">DELIVERY CHALLAN</h2>
              <p className="text-sm text-gray-600 mt-2">Challan number will be auto-generated when saved</p>
            </div>
          </div>

          {/* Company Information */}
          <div className="px-6 py-4 border-b border-gray-200">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              {/* Sun Power Services */}
              <div>
                <h3 className="text-lg font-semibold text-gray-900 mb-3">Sun Power Services</h3>
                <div className="space-y-2 text-sm text-gray-600">
                  <p>D No.53, Plot No.4, 4th Street, Phase-1 Extension,</p>
                  <p>Annai Velankanni Nagar, Madhananthapuram, Porur,</p>
                  <p>Chennai - 600116</p>
                  <p>Contact: 044-24828218, 9176660123</p>
                  <p>GSTIN/UIN: 33BLFPS9951M1ZC</p>
                  <p>State: Tamil Nadu, Code: 33</p>
                  <p>Email: sunpowerservices@gmail.com</p>
                </div>
              </div>

              {/* Customer Information */}
              <div>
                <h3 className="text-lg font-semibold text-gray-900 mb-3">Buyer (Bill to)</h3>
                <div className="space-y-3">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      Customer *
                    </label>
                    <div className="relative" ref={customerDropdownRef}>
                      <input
                        type="text"
                        value={customerSearchTerm}
                        onChange={(e) => setCustomerSearchTerm(e.target.value)}
                        onFocus={() => setShowCustomerDropdown(true)}
                        placeholder="Search customer..."
                        className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                      />
                      {showCustomerDropdown && (
                        <div className="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-md shadow-lg max-h-60 overflow-auto">
                          {getFilteredCustomers().map((customer) => (
                            <div
                              key={customer._id}
                              onClick={() => handleCustomerSelect(customer)}
                              className="px-3 py-2 hover:bg-gray-100 cursor-pointer"
                            >
                              <div className="font-medium">{customer.name}</div>
                              <div className="text-sm text-gray-500">{customer.email}</div>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                    {errors.customer && <p className="text-red-500 text-sm mt-1">{errors.customer}</p>}
                  </div>

                  {/* Address Selection - Only show when customer is selected */}
                  {formData.customer && (
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        Select Address *
                      </label>
                      <div className="relative">
                        <select
                          value={selectedAddressId}
                          onChange={(e) => handleAddressSelect(e.target.value)}
                          onFocus={() => setShowAddressDropdown(true)}
                          className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                        >
                          <option value="">Select an address</option>
                          {getSelectedCustomer()?.addresses?.map((address) => (
                            <option key={address.id} value={address.id}>
                              {address.address} - {address.district}, {address.pincode}
                              {address.isPrimary && ' (Primary)'}
                            </option>
                          ))}
                        </select>
                      </div>
                      {errors.address && <p className="text-red-500 text-sm mt-1">{errors.address}</p>}
                    </div>
                  )}

                  {/* Selected Address Details */}
                  {getSelectedAddress() && (
                    <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
                      <h4 className="text-sm font-medium text-gray-900 mb-3">Selected Address Details</h4>
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                        <div>
                          <span className="font-medium text-gray-700">Address:</span>
                          <span className="ml-2 text-gray-900">{getSelectedAddress()?.address}</span>
                        </div>
                        <div>
                          <span className="font-medium text-gray-700">District:</span>
                          <span className="ml-2 text-gray-900">{getSelectedAddress()?.district}</span>
                        </div>
                        <div>
                          <span className="font-medium text-gray-700">State:</span>
                          <span className="ml-2 text-gray-900">{getSelectedAddress()?.state}</span>
                        </div>
                        <div>
                          <span className="font-medium text-gray-700">Pincode:</span>
                          <span className="ml-2 text-gray-900">{getSelectedAddress()?.pincode}</span>
                        </div>
                        {getSelectedAddress()?.gstNumber && (
                          <div className="md:col-span-2">
                            <span className="font-medium text-gray-700">GST Number:</span>
                            <span className="ml-2 text-gray-900">{getSelectedAddress()?.gstNumber}</span>
                          </div>
                        )}
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>

          {/* Invoice Reference Information */}
          {formData.invoiceDetails && (
            <div className="px-6 py-4 border-b border-gray-200 bg-blue-50">
              <h3 className="text-lg font-semibold text-gray-900 mb-4">Reference Invoice Information</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div className="space-y-3">
                  <div className="flex items-center space-x-2">
                    <FileText className="w-5 h-5 text-blue-600" />
                    <span className="font-medium text-gray-700">Invoice Number:</span>
                    <span className="text-gray-900">{formData.invoiceDetails.invoiceNumber}</span>
                  </div>
                  <div className="flex items-center space-x-2">
                    <Calendar className="w-5 h-5 text-blue-600" />
                    <span className="font-medium text-gray-700">Invoice Date:</span>
                    <span className="text-gray-900">{new Date(formData.invoiceDetails.invoiceDate).toLocaleDateString()}</span>
                  </div>
                  <div className="flex items-center space-x-2">
                    <span className="font-medium text-gray-700">Total Amount:</span>
                    <span className="text-gray-900 font-semibold">₹{formData.invoiceDetails.totalAmount.toLocaleString()}</span>
                  </div>
                </div>
                <div className="space-y-3">
                  <div className="flex items-center space-x-2">
                    <User className="w-5 h-5 text-blue-600" />
                    <span className="font-medium text-gray-700">Customer:</span>
                    <span className="text-gray-900">{formData.invoiceDetails.customerName}</span>
                  </div>
                  <div className="flex items-center space-x-2">
                    <Package className="w-5 h-5 text-blue-600" />
                    <span className="font-medium text-gray-700">Items:</span>
                    <span className="text-gray-900">{formData.invoiceDetails.items.length} item(s)</span>
                  </div>
                </div>
              </div>
              
              {/* Invoice Items Details */}
              {formData.invoiceDetails.items.length > 0 && (
                <div className="mt-4">
                  <h4 className="text-md font-medium text-gray-900 mb-3">Invoice Items:</h4>
                  <div className="bg-white rounded-lg border border-gray-200 overflow-hidden">
                    <div className="grid grid-cols-4 gap-4 p-3 bg-gray-100 border-b border-gray-200 font-medium text-sm text-gray-700">
                      <div>Description</div>
                      <div className="text-right">Quantity</div>
                      <div className="text-right">Unit Price</div>
                      <div className="text-right">Total</div>
                    </div>
                    {formData.invoiceDetails.items.map((item, index) => (
                      <div key={index} className="grid grid-cols-4 gap-4 p-3 border-b border-gray-100 last:border-b-0">
                        <div className="text-sm text-gray-900">{item.description}</div>
                        <div className="text-sm text-gray-900 text-right">{item.quantity}</div>
                        <div className="text-sm text-gray-900 text-right">₹{item.unitPrice.toLocaleString()}</div>
                        <div className="text-sm text-gray-900 text-right font-medium">₹{(item.quantity * item.unitPrice).toLocaleString()}</div>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Delivery Details */}
          <div className="px-6 py-4 border-b border-gray-200">
            <h3 className="text-lg font-semibold text-gray-900 mb-4">Delivery Details</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Dated
                  </label>
                  <input
                    type="date"
                    value={formData.dated}
                    onChange={(e) => updateField('dated', e.target.value)}
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Mode/Terms of Payment
                  </label>
                  <input
                    type="text"
                    value={formData.modeOfPayment}
                    onChange={(e) => updateField('modeOfPayment', e.target.value)}
                    placeholder="Manual Entry (Alpha Numeric with sp)"
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Department *
                  </label>
                  <select
                    value={formData.department}
                    onChange={(e) => updateField('department', e.target.value)}
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  >
                    <option value="">Select Department</option>
                    {departments.map(dept => (
                      <option key={dept} value={dept}>{dept}</option>
                    ))}
                  </select>
                  {errors.department && <p className="text-red-500 text-sm mt-1">{errors.department}</p>}
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Terms of Delivery
                  </label>
                  <input
                    type="text"
                    value={formData.termsOfDelivery}
                    onChange={(e) => updateField('termsOfDelivery', e.target.value)}
                    placeholder="Manual Entry"
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                </div>
              </div>

              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Reference No
                  </label>
                  <input
                    type="text"
                                            value={formData.referenceNo}
                    onChange={(e) => updateField('referenceNo', e.target.value)}
                    placeholder="Manual Entry (Alpha Numeric with sp)"
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Other Reference No
                  </label>
                  <input
                    type="text"
                                            value={formData.otherReferenceNo}
                    onChange={(e) => updateField('otherReferenceNo', e.target.value)}
                    placeholder="Manual Entry (Alpha Numeric with sp)"
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Buyer's Order No.
                  </label>
                  <input
                    type="text"
                                            value={formData.buyersOrderNo}
                    onChange={(e) => updateField('buyersOrderNo', e.target.value)}
                    placeholder="Manual Entry"
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Dated (for Buyer's Order)
                  </label>
                  <input
                    type="date"
                    value={formData.buyersOrderDate}
                    onChange={(e) => updateField('buyersOrderDate', e.target.value)}
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                </div>
              </div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-4">
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Dispatch Doc No.
                  </label>
                  <input
                    type="text"
                    value={formData.dispatchDocNo}
                    onChange={(e) => updateField('dispatchDocNo', e.target.value)}
                    placeholder="Manual Entry"
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Destination (City/State) *
                  </label>
                  <input
                    type="text"
                    value={formData.destination}
                    onChange={(e) => updateField('destination', e.target.value)}
                    placeholder="e.g., Chennai, Tamil Nadu"
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                  {errors.destination && <p className="text-red-500 text-sm mt-1">{errors.destination}</p>}
                </div>
              </div>

              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Dispatched through
                  </label>
                  <input
                    type="text"
                    value={formData.dispatchedThrough}
                    onChange={(e) => updateField('dispatchedThrough', e.target.value)}
                    placeholder="Manual Entry"
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    From Location *
                  </label>
                  <div className="relative dropdown-container">
                    <input
                      type="text"
                      value={locationSearchTerm || (formData.location ? getLocationLabel(formData.location) : '')}
                      onChange={(e) => {
                        const value = e.target.value;
                        setLocationSearchTerm(value);
                        
                        // If input is cleared, clear the location selection
                        if (!value) {
                          setFormData(prev => ({ ...prev, location: '' }));
                        }
                        
                        if (!showLocationDropdown) setShowLocationDropdown(true);
                        setHighlightedLocationIndex(-1);
                      }}
                      onFocus={() => {
                        setShowLocationDropdown(true);
                        setHighlightedLocationIndex(-1);
                      }}
                      autoComplete="off"
                      onKeyDown={handleLocationKeyDown}
                      placeholder="Search location or press ↓ to open"
                      data-field="location"
                      className="w-full px-3 py-2 pr-10 border border-gray-300 rounded-lg transition-colors focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                    />
                    <div className="absolute inset-y-0 right-0 flex items-center pr-3">
                      {formData.location && !locationSearchTerm && (
                        <button
                          type="button"
                          onClick={() => {
                            setFormData(prev => ({ ...prev, location: '' }));
                            setLocationSearchTerm('');
                          }}
                          className="text-gray-400 hover:text-gray-600 mr-2"
                        >
                          <X className="w-4 h-4" />
                        </button>
                      )}
                      <ChevronDown className={`w-4 h-4 text-gray-400 transition-transform ${showLocationDropdown ? 'rotate-180' : ''}`} />
                    </div>
                    {showLocationDropdown && (
                      <div className="absolute top-full left-0 right-0 mt-1 bg-white border border-gray-200 rounded-md shadow-lg z-50 py-0.5 max-h-60 overflow-y-auto">
                        <div className="px-3 py-2 text-center text-xs text-gray-500 bg-gray-50 border-b border-gray-200">
                          <kbd className="px-1 py-0.5 bg-gray-200 rounded text-xs">↑↓</kbd> Navigate •
                          <kbd className="px-1 py-0.5 bg-gray-200 rounded text-xs ml-1">Enter/Tab</kbd> Select •
                          <kbd className="px-1 py-0.5 bg-gray-200 rounded text-xs ml-1">Esc</kbd> Close
                        </div>

                        <button
                          onClick={() => {
                            setFormData({ ...formData, location: '' });
                            setShowLocationDropdown(false);
                            setLocationSearchTerm('');
                          }}
                          className={`w-full px-3 py-2 text-left hover:bg-gray-50 transition-colors text-sm ${!formData.location ? 'bg-blue-50 text-blue-600' : 'text-gray-700'}`}
                        >
                          Select location
                        </button>

                        {getFilteredLocations().map((location, index) => (
                          <button
                            key={location._id}
                            data-location-index={index}
                            onClick={() => {
                              console.log(`🔄 Location changed from ${formData.location} to ${location._id} (${location.name})`);
                              setFormData({ ...formData, location: location._id });
                              setShowLocationDropdown(false);
                              setLocationSearchTerm('');
                              setHighlightedLocationIndex(-1);
                              // Clear stock cache when location changes
                              setProductStockCache({});
                              setStockValidation({});

                              // Refresh products for the new location
                              setTimeout(() => {
                                fetchProductsByLocation(location._id);
                              }, 100);
                            }}
                            className={`w-full px-3 py-2 text-left transition-colors text-sm ${formData.location === location._id ? 'bg-blue-100 text-blue-800' :
                              highlightedLocationIndex === index ? 'bg-blue-200 text-blue-900 border-l-4 border-l-blue-600' :
                                'text-gray-700 hover:bg-gray-50'
                              }`}
                          >
                            <div>
                              <div className="font-medium">{location.name}</div>
                              <div className="text-xs text-gray-500 capitalize">{location.type.replace('_', ' ')}</div>
                            </div>
                          </button>
                        ))}
                      </div>
                    )}
                  </div>
                  {errors.location && <p className="text-red-500 text-sm mt-1">{errors.location}</p>}
                </div>
              </div>
            </div>
          </div>

          {/* Consignee (Ship to) Section */}
          <div className="px-6 py-4 border-b border-gray-200">
            <h3 className="text-lg font-semibold text-gray-900 mb-3">Consignee (Ship to)</h3>
            <div className="space-y-3">
              {/* Ship-to Address Selection - Only show when customer is selected */}
              {formData.customer && (
                <div>
                  <div className="relative">
                    <select
                      value={selectedShipToAddressId}
                      onChange={(e) => handleShipToAddressSelect(e.target.value)}
                      className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                    >
                      <option value="">{formData.consignee || '—'}</option>
                      {getSelectedCustomer()?.addresses?.map((address: any) => (
                        <option key={address.id} value={address.id}>
                          {address.address} - {address.district}, {address.pincode}
                          {address.isPrimary && ' (Primary)'}
                        </option>
                      ))}
                    </select>
                  </div>
                  {errors.shipToAddress && <p className="text-red-500 text-sm mt-1">{errors.shipToAddress}</p>}
                </div>
              )}

              {/* Same as Bill-to Address Button */}
              {formData.customer && selectedAddressId && (
                <div className="mt-2">
                  <button
                    type="button"
                    onClick={() => {
                      console.log('Setting ship-to address same as bill-to address:', selectedAddressId);
                      setSelectedShipToAddressId(selectedAddressId);
                    }}
                    className="px-3 py-1 text-sm text-blue-600 hover:text-blue-800 underline"
                  >
                    Same as Bill-to Address
                  </button>
                </div>
              )}

              {/* Selected Ship-to Address Details */}
              {getSelectedShipToAddress() && (
                <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
                  <h4 className="text-sm font-medium text-gray-900 mb-3">Selected Ship-to Address Details</h4>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                    <div>
                      <span className="font-medium text-gray-700">Address:</span>
                      <span className="ml-2 text-gray-900">{getSelectedShipToAddress()?.address}</span>
                    </div>
                    <div>
                      <span className="font-medium text-gray-700">District:</span>
                      <span className="ml-2 text-gray-900">{getSelectedShipToAddress()?.district}</span>
                    </div>
                    <div>
                      <span className="font-medium text-gray-700">State:</span>
                      <span className="ml-2 text-gray-900">{getSelectedShipToAddress()?.state}</span>
                    </div>
                    <div>
                      <span className="font-medium text-gray-700">Pincode:</span>
                      <span className="ml-2 text-gray-900">{getSelectedShipToAddress()?.pincode}</span>
                    </div>
                    {getSelectedShipToAddress()?.gstNumber && (
                      <div className="md:col-span-2">
                        <span className="font-medium text-gray-700">GST Number:</span>
                        <span className="ml-2 text-gray-900">{getSelectedShipToAddress()?.gstNumber}</span>
                      </div>
                    )}
                  </div>
                </div>
              )}
            </div>
          </div>

          {/* Spares Table */}
          <div className="px-6 py-4 border-b border-gray-200">
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-lg font-semibold text-gray-900">Spares</h3>
              <button
                type="button"
                onClick={addSpareItem}
                className="px-3 py-1 bg-blue-600 text-white rounded-md text-sm hover:bg-blue-700"
              >
                Add Item
              </button>
            </div>
            
            {/* Table Header */}
            <div className="overflow-x-auto">
              <div className="min-w-[1000px]">
                <div className="grid bg-gray-200 border border-gray-300 rounded-t-lg" 
                     style={{ gridTemplateColumns: isEditMode ? '60px 1fr 120px 100px 80px 120px 60px' : '60px 1fr 120px 100px 80px 60px' }}>
                  <div className="p-3 border-r border-gray-300 bg-gray-200 font-medium text-sm">S.No</div>
                  <div className="p-3 border-r border-gray-300 bg-gray-200 font-medium text-sm">Description of Goods</div>
                  <div className="p-3 border-r border-gray-300 bg-gray-200 font-medium text-sm">Part No.</div>
                  <div className="p-3 border-r border-gray-300 bg-gray-200 font-medium text-sm">HSN/SAC</div>
                  <div className="p-3 border-r border-gray-300 bg-gray-200 font-medium text-sm">Quantity</div>
                  {isEditMode && (
                    <div className="p-3 border-r border-gray-300 bg-gray-200 font-medium text-sm">Stock Operation</div>
                  )}
                  <div className="p-3 text-center bg-gray-200 font-medium text-sm">Action</div>
                </div>
              </div>

              {/* Table Body */}
              <div className="divide-y divide-gray-200 min-w-[1000px] border-b border-gray-300">
                {formData.spares.length === 0 ? (
                  <div className="px-3 py-8 text-center text-gray-500">
                    <div className="flex flex-col items-center space-y-2">
                      <Package className="w-8 h-8 text-gray-300" />
                      <p className="text-sm">No spares added</p>
                      <p className="text-xs text-gray-400">Click "Add Item" to add spare items (optional)</p>
                    </div>
                  </div>
                ) : (
                  formData.spares.map((item, index) => (
                  <div key={index} className={`grid group hover:bg-blue-50 transition-colors ${index % 2 === 0 ? 'bg-white' : 'bg-gray-50'}`}
                       style={{ gridTemplateColumns: isEditMode ? '60px 1fr 120px 100px 80px 120px 60px' : '60px 1fr 120px 100px 80px 60px' }}>
                    
                    {/* S.No */}
                    <div className="p-2 border-r border-gray-200 text-center text-sm font-medium text-gray-600 flex items-center justify-center">
                      {item.slNo}
                    </div>

                    {/* Description */}
                    <div className="p-1 border-r border-gray-200 relative">
                      <input
                        type="text"
                        value={item.description || productSearchTerms[`spares-${index}`] || ''}
                        onChange={(e) => {
                          updateProductSearchTerm(index, e.target.value, 'spares');
                          setShowProductDropdowns(prev => ({
                            ...prev,
                            [`spares-${index}`]: true
                          }));
                          prefetchAvailabilityForVisibleProducts(index, e.target.value);
                        }}
                        onFocus={() => {
                          // If there's already a selected product, clear the search term to show the product description
                          if (item.description) {
                            updateProductSearchTerm(index, '', 'spares');
                          }
                          setShowProductDropdowns(prev => ({
                            ...prev,
                            [`spares-${index}`]: true
                          }));
                          prefetchAvailabilityForVisibleProducts(index);
                        }}
                        onBlur={() => {
                          setTimeout(() => {
                            setShowProductDropdowns(prev => ({
                              ...prev,
                              [`spares-${index}`]: false
                            }));
                          }, 200);
                        }}
                        className="w-full p-2 border-0 bg-transparent text-sm focus:outline-none focus:bg-blue-50"
                        placeholder="Type to search products..."
                        autoComplete="off"
                      />
                      {item.stockLocation && (
                        <div className="absolute top-0 right-0 flex flex-col gap-1">
                          <div className="text-xs text-purple-600 bg-purple-100 px-2 py-1 rounded text-center font-medium">
                            📍 {item.stockLocation.room} → {item.stockLocation.rack}
                          </div>
                          {(() => {
                            // Find the stock product to get available quantity
                            const stockProduct = stockProducts.find(sp => sp._id === item.stockId);
                            if (stockProduct) {
                              return (
                                <div className="text-xs text-green-600 bg-green-100 px-2 py-1 rounded text-center font-medium">
                                  📦 {stockProduct.availableQuantity} units
                                </div>
                              );
                            }
                            return null;
                          })()}
                        </div>
                      )}
                      {showProductDropdowns[`spares-${index}`] && (
                        <div
                          className="fixed bg-white border border-gray-300 rounded-md shadow-xl z-[9999] max-h-[400px] overflow-hidden product-dropdown"
                          style={{ 
                            width: '450px', 
                            minWidth: '450px'
                          }}
                          ref={(el) => {
                            if (el) {
                              // Position the dropdown relative to the input field
                              const inputEl = el.parentElement?.querySelector('input');
                              if (inputEl) {
                                const inputRect = inputEl.getBoundingClientRect();
                                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                                const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
                                
                                el.style.top = `${inputRect.bottom + scrollTop + 4}px`;
                                el.style.left = `${inputRect.left + scrollLeft}px`;
                              }
                            }
                          }}
                        >
                          <div className="p-2 border-b border-gray-200 bg-gray-50">
                            <div className="text-xs text-gray-600">
                              {getFilteredProducts(productSearchTerms[`spares-${index}`] || '').length} products found
                              {productSearchTerms[`spares-${index}`] && (
                                <span className="ml-2 text-blue-600 font-medium">
                                  for "{productSearchTerms[`spares-${index}`]}"
                                </span>
                              )}
                            </div>
                          </div>

                          <div className="overflow-y-auto max-h-96">
                            {getFilteredProducts(productSearchTerms[`spares-${index}`] || '').length === 0 ? (
                              <div className="px-3 py-4 text-center text-sm text-gray-500">
                                <div>No products found</div>
                                <div className="text-xs mt-1">Try different search terms</div>
                              </div>
                            ) : (
                              getFilteredProducts(productSearchTerms[`spares-${index}`] || '').map((stockProduct, productIndex) => (
                                <button
                                  key={`${stockProduct.product._id}-${stockProduct._id}`}
                                  onMouseDown={(e) => {
                                    e.preventDefault();
                                    handleProductSelect(index, stockProduct._id);
                                  }}
                                  className={`w-full px-4 py-3 text-left hover:bg-blue-50 transition-colors text-sm border-b border-gray-100 last:border-b-0 ${item.stockId === stockProduct._id ? 'bg-blue-100 text-blue-800' :
                                    'text-gray-700'
                                    }`}
                                >
                                  <div className="flex justify-between items-start">
                                    <div className="flex-1 min-w-0 pr-4">
                                      <div className="font-medium text-gray-900 mb-1 flex items-center">
                                        <div><span className="font-medium">Part No:</span>{stockProduct.product?.partNo}</div>
                                      </div>
                                      <div className="text-xs text-gray-600 space-y-0.5">
                                        <div><span className="font-medium">Product Name:</span> {stockProduct.product?.name || 'N/A'}</div>
                                        <div className="text-blue-600 font-medium">
                                          📍 {stockProduct.stockLocation.location} → {stockProduct.stockLocation.room} → {stockProduct.stockLocation.rack}
                                        </div>
                                        <div className="text-green-600 font-medium">
                                          📦 Available: {stockProduct.availableQuantity} units
                                        </div>
                                        <div className="text-purple-600 font-medium text-xs">
                                          🏷️ Stock ID: {stockProduct._id.slice(-8)}
                                        </div>
                                      </div>
                                    </div>
                                    <div className="text-right flex-shrink-0 ml-4">
                                      <div className="font-bold text-lg text-green-600">₹{stockProduct.product?.gndp?.toLocaleString() || stockProduct.product?.price?.toLocaleString() || 0}</div>
                                      <div className="text-xs text-gray-500 mt-0.5">GNDP</div>
                                    </div>
                                  </div>
                                </button>
                              ))
                            )}
                          </div>
                        </div>
                      )}
                      {errors[`spare-${index}-description`] && (
                        <p className="text-red-500 text-xs mt-1">{errors[`spare-${index}-description`]}</p>
                      )}
                      {errors[`spare-${index}-product`] && (
                        <p className="text-red-500 text-xs mt-1">{errors[`spare-${index}-product`]}</p>
                      )}
                      {/* Stock Allocation Details */}
                      {item.product && item.quantity > 0 && stockAllocation[`${item.product}-${index}`] && (
                        <div className="mt-2 rounded-md border border-blue-200 bg-blue-50">
                          <div className="flex items-center justify-between px-3 py-2 border-b border-blue-200">
                            <div className="text-xs font-semibold text-blue-800">
                              Stock Allocation for <span className="font-bold">{item.quantity}</span> units
                            </div>
                            <div className="text-[10px] text-blue-700">
                              {stockAllocation[`${item.product}-${index}`].canFulfill ? (
                                <span className="inline-flex items-center rounded-full bg-blue-100 px-2 py-0.5 font-medium text-blue-700">Fully allocated</span>
                              ) : (
                                <span className="inline-flex items-center rounded-full bg-red-100 px-2 py-0.5 font-medium text-red-700">Insufficient stock</span>
                              )}
                            </div>
                          </div>

                          {/* Header */}
                          <div className="grid grid-cols-5 gap-2 px-3 py-2 text-[10px] font-medium text-blue-900">
                            <div>Location</div>
                            <div>Room</div>
                            <div>Rack</div>
                            <div className="text-right">Allocated</div>
                            <div className="text-right">Available</div>
                          </div>

                          {/* Rows */}
                          <div className="px-3 pb-2">
                            <div className="space-y-1">
                              {stockAllocation[`${item.product}-${index}`].allocations.map((alloc, allocIndex) => (
                                <div
                                  key={allocIndex}
                                  className="grid grid-cols-5 gap-2 items-center rounded bg-white px-2 py-1 text-[11px] text-blue-800 shadow-sm"
                                >
                                  <div className="truncate" title={alloc.location}>{alloc.location}</div>
                                  <div className="truncate" title={alloc.room}>{alloc.room}</div>
                                  <div className="truncate" title={alloc.rack}>{alloc.rack}</div>
                                  <div className="text-right">
                                    <span className="inline-flex items-center rounded bg-blue-100 px-2 py-0.5 font-semibold text-blue-700">
                                      {alloc.allocatedQuantity}
                                    </span>
                                  </div>
                                  <div className="text-right">
                                    <span className="inline-flex items-center rounded bg-slate-100 px-2 py-0.5 font-medium text-slate-700">
                                      {alloc.availableQuantity}
                                    </span>
                                  </div>
                                </div>
                              ))}
                            </div>
                          </div>

                          {!stockAllocation[`${item.product}-${index}`].canFulfill && (
                            <div className="px-3 pb-2 text-[11px] font-medium text-red-600">
                              ⚠️ Insufficient stock to fulfill complete order
                            </div>
                          )}
                        </div>
                      )}
                    </div>

                    {/* Part No */}
                    <div className="p-1 border-r border-gray-200">
                      <input
                        type="text"
                        value={item.partNo}
                        onChange={(e) => updateSpareItem(index, 'partNo', e.target.value)}
                        className="w-full p-2 border-0 bg-transparent text-sm focus:outline-none focus:bg-blue-50"
                        placeholder="Auto-filled from product"
                        readOnly
                      />
                    </div>

                    {/* HSN/SAC */}
                    <div className="p-1 border-r border-gray-200">
                      <input
                        type="text"
                        value={item.hsnSac}
                        onChange={(e) => updateSpareItem(index, 'hsnSac', e.target.value)}
                        className="w-full p-2 border-0 bg-transparent text-sm focus:outline-none focus:bg-blue-50"
                        placeholder="Auto-filled from product"
                        readOnly
                      />
                    </div>

                    {/* Quantity */}
                    <div className="p-1 border-r border-gray-200">
                      <input
                        type="number"
                        value={item.quantity || ''}
                        onChange={(e) => {
                          const value = e.target.value;
                          if (value === '') {
                            updateSpareItem(index, 'quantity', 0);
                            // Clear stock allocation when quantity is cleared
                            if (item.product) {
                              setStockAllocation(prev => {
                                const newAllocation = { ...prev };
                                delete newAllocation[`${item.product}-${index}`];
                                return newAllocation;
                              });
                            }
                          } else {
                            const numValue = parseInt(value);
                            if (!isNaN(numValue) && numValue >= 0) {
                              updateSpareItem(index, 'quantity', numValue);
                              
                              // Calculate sequential stock allocation when quantity changes
                              if (item.product && numValue > 0) {
                                const allocation = calculateSequentialStockAllocation(item.product, numValue);
                                if (allocation) {
                                  setStockAllocation(prev => ({
                                    ...prev,
                                    [`${item.product}-${index}`]: allocation
                                  }));
                                  
                                  // Show toast if allocation cannot be fulfilled
                                  if (!allocation.canFulfill) {
                                    const totalAvailable = allocation.allocations.reduce((sum, alloc) => sum + alloc.availableQuantity, 0);
                                    toast.error(`Insufficient stock! Requested: ${numValue}, Available: ${totalAvailable}`);
                                  } else {
                                    // Show allocation details
                                    const allocationDetails = allocation.allocations.map(alloc => 
                                      `${alloc.allocatedQuantity} from ${alloc.location} - ${alloc.room} - ${alloc.rack}`
                                    ).join(', ');
                                    toast.success(`Stock allocated: ${allocationDetails}`);
                                  }
                                }
                              }
                              
                              // Validate stock when quantity changes
                              if (item.product) {
                                validateStockForItem(index, item.product, numValue);
                              }
                            }
                          }
                        }}
                        onBlur={(e) => {
                          // Ensure we have a valid number on blur
                          if (e.target.value === '' || isNaN(parseInt(e.target.value))) {
                            updateSpareItem(index, 'quantity', 0);
                          }
                        }}
                        min="0"
                        className={`w-full p-2 border-0 bg-transparent text-sm focus:outline-none focus:bg-blue-50 text-right ${
                          stockValidation[index] && !stockValidation[index].isValid ? 'text-red-600' : ''
                        }`}
                        placeholder="Enter quantity"
                      />
                      {errors[`spare-${index}-quantity`] && (
                        <p className="text-red-500 text-xs mt-1">{errors[`spare-${index}-quantity`]}</p>
                      )}
                      
                      
                    </div>

                    {/* Stock Operation (Edit Mode Only) */}
                    {isEditMode && (
                      <div className="p-1 border-r border-gray-200">
                        <select
                          value={item.stockOperation || 'reduce'}
                          onChange={(e) => updateSpareItem(index, 'stockOperation', e.target.value as 'add' | 'reduce')}
                          className="w-full p-2 border border-gray-300 rounded text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
                        >
                          <option value="reduce">Reduce Stock</option>
                          <option value="add">Add Stock</option>
                        </select>
                      </div>
                    )}

                    {/* Action */}
                    <div className="p-2 text-center">
                      {formData.spares.length > 0 && (
                        <button
                          type="button"
                          onClick={() => removeSpareItem(index)}
                          className="text-red-600 hover:text-red-800 text-sm"
                        >
                          <Trash2 className="w-4 h-4" />
                        </button>
                      )}
                    </div>
                  </div>
                ))
              )}
                          </div>
            </div>
          </div>

          {/* Services Table */}
          <div className="px-6 py-4 border-b border-gray-200">
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-lg font-semibold text-gray-900">Service (Optional)</h3>
              <button
                type="button"
                onClick={addServiceItem}
                className="px-3 py-1 bg-green-600 text-white rounded-md text-sm hover:bg-green-700"
              >
                Add Service
              </button>
            </div>
            
            <div className="overflow-x-auto">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Sl No</th>
                    <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Description of Goods</th>
                    <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Part No.</th>
                    <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">HSN/SAC</th>
                    <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Quantity</th>
                    <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Action</th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {formData.services.length === 0 ? (
                    <tr>
                      <td colSpan={6} className="px-3 py-8 text-center text-gray-500">
                        <div className="flex flex-col items-center space-y-2">
                          <Package className="w-8 h-8 text-gray-300" />
                          <p className="text-sm">No services added</p>
                          <p className="text-xs text-gray-400">Click "Add Service" to add service items (optional)</p>
                        </div>
                      </td>
                    </tr>
                  ) : (
                    formData.services.map((item, index) => (
                      <tr key={index}>
                        <td className="px-3 py-2 whitespace-nowrap text-sm text-gray-900">{item.slNo}</td>
                        <td className="px-3 py-2 whitespace-nowrap">
                          <input
                            type="text"
                            value={item.description}
                            onChange={(e) => updateServiceItem(index, 'description', e.target.value)}
                            placeholder="Enter service description..."
                            className="w-full px-2 py-1 border border-gray-300 rounded text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
                          />
                          {errors[`service-${index}-description`] && (
                            <p className="text-red-500 text-xs mt-1">{errors[`service-${index}-description`]}</p>
                          )}
                        </td>
                        <td className="px-3 py-2 whitespace-nowrap">
                          <input
                            type="text"
                            value={item.partNo}
                            onChange={(e) => updateServiceItem(index, 'partNo', e.target.value)}
                            placeholder="Manual"
                            className="w-full px-2 py-1 border border-gray-300 rounded text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
                          />
                        </td>
                        <td className="px-3 py-2 whitespace-nowrap">
                          <input
                            type="text"
                            value={item.hsnSac}
                            onChange={(e) => updateServiceItem(index, 'hsnSac', e.target.value)}
                            placeholder="Manual"
                            className="w-full px-2 py-1 border border-gray-300 rounded text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
                          />
                        </td>
                        <td className="px-3 py-2 whitespace-nowrap">
                          <input
                            type="number"
                            value={item.quantity || ''}
                            onChange={(e) => {
                              const value = e.target.value;
                              if (value === '') {
                                updateServiceItem(index, 'quantity', 0);
                              } else {
                                const numValue = parseInt(value);
                                if (!isNaN(numValue) && numValue >= 0) {
                                  updateServiceItem(index, 'quantity', numValue);
                                }
                              }
                            }}
                            onBlur={(e) => {
                              // Ensure we have a valid number on blur
                              if (e.target.value === '' || isNaN(parseInt(e.target.value))) {
                                updateServiceItem(index, 'quantity', 0);
                              }
                            }}
                            min="0"
                            className="w-full px-2 py-1 border border-gray-300 rounded text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
                          />
                          {errors[`service-${index}-quantity`] && (
                            <p className="text-red-500 text-xs mt-1">{errors[`service-${index}-quantity`]}</p>
                          )}
                        </td>
                        <td className="px-3 py-2 whitespace-nowrap">
                          <button
                            type="button"
                            onClick={() => removeServiceItem(index)}
                            className="text-red-600 hover:text-red-800 text-sm"
                          >
                            <Trash2 className="w-4 h-4" />
                          </button>
                        </td>
                      </tr>
                    ))
                  )}
                </tbody>
              </table>
            </div>
          </div>

          {/* Footer */}
          <div className="px-6 py-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Notes
                </label>
                <textarea
                                          value={formData.notes}
                  onChange={(e) => updateField('notes', e.target.value)}
                  rows={3}
                  placeholder="Additional notes..."
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
              
              <div className="flex items-end justify-between">
                <div className="text-sm text-gray-600">
                  <p>Company's PAN: BLFPS9951M</p>
                  <p className="mt-2">Recd. in Good Condition: _________________</p>
                  <p className="mt-4">E & OE</p>
                </div>
                
                <Button
                  type="submit"
                  form="delivery-challan-form"
                  disabled={submitting}
                  className="bg-gradient-to-r from-blue-600 to-blue-700 text-white px-6 py-2 rounded-lg flex items-center space-x-2 hover:from-blue-700 hover:to-blue-800 transition-all duration-300 shadow-md hover:shadow-lg transform hover:scale-105 disabled:opacity-50"
                >
                  <Save className="w-4 h-4" />
                  <span>{submitting ? 'Saving...' : 'Save Challan'}</span>
                </Button>
              </div>
            </div>
          </div>
        </form>
      </div>
    </div>
  );
}

export default DeliveryChallanForm; 